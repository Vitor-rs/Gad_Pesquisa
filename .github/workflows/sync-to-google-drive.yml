name: Sync Repository to Google Drive as Folder

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  sync-to-drive:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install Dependencies
      run: |
        pip install google-api-python-client google-auth google-auth-oauthlib google-auth-httplib2
        
    - name: Pre-check Environment Variables
      run: |
        python << EOF
        import os
        import sys
        
        print("ðŸ” Verificando variÃ¡veis de ambiente...")
        print("=" * 60)
        
        # VariÃ¡veis necessÃ¡rias
        required_vars = {
            'GOOGLE_CREDENTIALS': '${{ secrets.GOOGLE_CREDENTIALS }}',
            'GOOGLE_DRIVE_FOLDER_ID': '${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}'
        }
        
        # VariÃ¡veis opcionais do repositÃ³rio
        repo_vars = {
            'REPOSITORY_NAME': '${{ github.event.repository.name }}',
            'BRANCH': '${{ github.ref_name }}',
            'COMMIT_SHA': '${{ github.sha }}',
            'ACTOR': '${{ github.actor }}'
        }
        
        missing_vars = []
        
        # Verificar variÃ¡veis essenciais
        for name, value in required_vars.items():
            if value and value.strip():
                if 'CREDENTIALS' in name:
                    print(f"âœ… {name}: {'*' * 8}")
                else:
                    print(f"âœ… {name}: {value}")
            else:
                print(f"âŒ {name}: NÃƒO ENCONTRADA")
                missing_vars.append(name)
        
        # Mostrar variÃ¡veis do repositÃ³rio
        print("\nðŸ“‹ InformaÃ§Ãµes do repositÃ³rio:")
        for name, value in repo_vars.items():
            print(f"â„¹ï¸  {name}: {value}")
        
        # Verificar se temos o mÃ­nimo necessÃ¡rio
        if missing_vars:
            print(f"\nâŒ ERRO: VariÃ¡veis essenciais nÃ£o encontradas: {', '.join(missing_vars)}")
            print("\nVerifique se vocÃª configurou os secrets no GitHub:")
            print("- VÃ¡ em Settings â†’ Secrets and variables â†’ Actions")
            print("- Configure GOOGLE_CREDENTIALS e GOOGLE_DRIVE_FOLDER_ID")
            sys.exit(1)
        
        print("\nâœ… Todas as variÃ¡veis necessÃ¡rias foram encontradas!")
        print("ðŸš€ Prosseguindo com a sincronizaÃ§Ã£o...")
        EOF
        
    - name: Setup Google Credentials
      run: |
        echo '${{ secrets.GOOGLE_CREDENTIALS }}' | base64 -d > credentials.json
        echo "GOOGLE_APPLICATION_CREDENTIALS=credentials.json" >> $GITHUB_ENV
        
    - name: Validate Google Drive Connection
      run: |
        python << EOF
        import os
        from google.oauth2 import service_account
        from googleapiclient.discovery import build
        
        print("ðŸ”— Testando conexÃ£o com Google Drive...")
        
        try:
            credentials = service_account.Credentials.from_service_account_file(
                'credentials.json',
                scopes=['https://www.googleapis.com/auth/drive']
            )
            
            service = build('drive', 'v3', credentials=credentials)
            
            folder_id = '${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}'
            folder_info = service.files().get(fileId=folder_id).execute()
            
            print(f"âœ… ConexÃ£o estabelecida com sucesso!")
            print(f"ðŸ“ Pasta de destino: {folder_info.get('name')}")
            print(f"ðŸ†” ID da pasta: {folder_id}")
            
            permissions = service.permissions().list(fileId=folder_id).execute()
            print(f"ðŸ” PermissÃµes configuradas: {len(permissions.get('permissions', []))} entrada(s)")
            
        except Exception as e:
            print(f"âŒ Erro ao conectar com Google Drive: {str(e)}")
            print("\nðŸ’¡ PossÃ­veis causas:")
            print("- Credenciais invÃ¡lidas ou expiradas")
            print("- Pasta nÃ£o encontrada ou sem permissÃ£o")
            print("- Google Drive API nÃ£o habilitada")
            raise
        EOF
        
    - name: Sync Repository to Google Drive Folder
      run: |
        python << EOF
        import os
        from datetime import datetime
        from pathlib import Path
        from google.oauth2 import service_account
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaFileUpload
        
        # ConfiguraÃ§Ãµes
        repo_name = '${{ github.event.repository.name }}'
        branch = '${{ github.ref_name }}'
        commit_sha = '${{ github.sha }}'
        folder_id = '${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}'
        
        print("ðŸ”„ Sincronizando repositÃ³rio como pasta no Google Drive...")
        print(f"ðŸ“ RepositÃ³rio: {repo_name}")
        print(f"ðŸ”€ Branch: {branch}")
        print(f"ðŸ“ Commit: {commit_sha[:8]}")
        
        # Configurar Google Drive
        credentials = service_account.Credentials.from_service_account_file(
            'credentials.json',
            scopes=['https://www.googleapis.com/auth/drive']
        )
        
        service = build('drive', 'v3', credentials=credentials)
        
        # Verificar se pasta do repositÃ³rio jÃ¡ existe
        query = f"name = '{repo_name}' and '{folder_id}' in parents and mimeType = 'application/vnd.google-apps.folder' and trashed = false"
        
        results = service.files().list(
            q=query,
            fields='files(id,name)'
        ).execute()
        
        existing_folders = results.get('files', [])
        
        if existing_folders:
            repo_folder_id = existing_folders[0]['id']
            print(f"ðŸ“ Pasta encontrada: {repo_name} (ID: {repo_folder_id})")
            
            # Limpar conteÃºdo existente - apenas tentar, ignorar erros de permissÃ£o
            print("ðŸ§¹ Limpando pasta existente...")
            files_query = f"'{repo_folder_id}' in parents and trashed = false"
            try:
                files_to_delete = service.files().list(q=files_query, fields='files(id,name)').execute().get('files', [])
                
                for file in files_to_delete:
                    try:
                        service.files().delete(fileId=file['id']).execute()
                        print(f"  ðŸ—‘ï¸  Removido: {file['name']}")
                    except Exception as e:
                        # Apenas avisar, nÃ£o falhar
                        print(f"  âš ï¸ NÃ£o foi possÃ­vel remover {file['name']}: Sem permissÃ£o")
            except Exception as e:
                print(f"  âš ï¸ Aviso durante limpeza: {str(e)[:50]}...")
        else:
            # Criar nova pasta
            print(f"ðŸ“ Criando pasta: {repo_name}")
            
            folder_metadata = {
                'name': repo_name,
                'mimeType': 'application/vnd.google-apps.folder',
                'parents': [folder_id]
            }
            
            folder = service.files().create(
                body=folder_metadata,
                fields='id'
            ).execute()
            
            repo_folder_id = folder.get('id')
        
        # FunÃ§Ãµes de upload
        def get_mime_type(file_path):
            ext = Path(file_path).suffix.lower()
            mime_types = {
                '.txt': 'text/plain',
                '.py': 'text/x-python',
                '.md': 'text/markdown',
                '.json': 'application/json',
                '.yml': 'text/yaml',
                '.yaml': 'text/yaml',
                '.html': 'text/html',
                '.css': 'text/css',
                '.js': 'application/javascript'
            }
            return mime_types.get(ext, 'application/octet-stream')
        
        def should_ignore_file(file_path):
            ignored_files = {'.gitignore', '.gitattributes', 'credentials.json'}
            ignored_extensions = {'.pyc', '.pyo', '.pyd', '.log', '.tmp'}
            
            name = Path(file_path).name
            
            if name in ignored_files:
                return False  # Manter .gitignore
            
            if Path(file_path).suffix in ignored_extensions:
                return True
                
            if name.startswith('.') and name not in {'.gitignore'}:
                return True
                
            return False
        
        def find_existing_file_or_folder(service, parent_id, name):
            try:
                query = f"name = '{name}' and '{parent_id}' in parents and trashed = false"
                results = service.files().list(q=query, fields='files(id,name,mimeType)').execute()
                files = results.get('files', [])
                return files[0] if files else None
            except:
                return None
        
        def upload_file(service, file_path, parent_id, path_prefix=""):
            try:
                name = Path(file_path).name
                
                # Verificar se arquivo jÃ¡ existe
                existing = find_existing_file_or_folder(service, parent_id, name)
                
                file_metadata = {'name': name}
                if not existing:
                    file_metadata['parents'] = [parent_id]
                
                media = MediaFileUpload(
                    file_path,
                    mimetype=get_mime_type(file_path),
                    resumable=True
                )
                
                if existing:
                    # Tentar atualizar arquivo existente
                    try:
                        file = service.files().update(
                            fileId=existing['id'],
                            media_body=media,
                            fields='id,name'
                        ).execute()
                        print(f"  ðŸ”„ {path_prefix}{name}")
                    except Exception as e:
                        # Se nÃ£o conseguir atualizar, criar novo com sufixo
                        timestamp = datetime.now().strftime('%H%M%S')
                        new_name = f"{Path(name).stem}_sync_{timestamp}{Path(name).suffix}"
                        file_metadata['name'] = new_name
                        file_metadata['parents'] = [parent_id]
                        
                        file = service.files().create(
                            body=file_metadata,
                            media_body=media,
                            fields='id,name'
                        ).execute()
                        print(f"  âœ… {path_prefix}{new_name} (duplicata resolvida)")
                else:
                    # Criar novo arquivo
                    file = service.files().create(
                        body=file_metadata,
                        media_body=media,
                        fields='id,name'
                    ).execute()
                    print(f"  âœ… {path_prefix}{name}")
                
                return True
                
            except Exception as e:
                print(f"  âŒ Erro ao enviar {path_prefix}{name}: {str(e)[:50]}...")
                return False
        
        def upload_directory(service, local_path, parent_id, path_prefix=""):
            uploaded_count = 0
            
            for item in sorted(os.listdir(local_path)):
                # Ignorar pastas/arquivos especÃ­ficos
                if item in {'.git', '__pycache__', 'node_modules', '.github'}:
                    continue
                
                item_path = os.path.join(local_path, item)
                item_relative = os.path.join(path_prefix, item) if path_prefix else item
                
                if os.path.isfile(item_path):
                    if should_ignore_file(item_path):
                        continue
                        
                    if upload_file(service, item_path, parent_id, path_prefix):
                        uploaded_count += 1
                        
                elif os.path.isdir(item_path):
                    try:
                        # Verificar se pasta jÃ¡ existe
                        existing = find_existing_file_or_folder(service, parent_id, item)
                        
                        if existing and existing.get('mimeType') == 'application/vnd.google-apps.folder':
                            subfolder_id = existing['id']
                            print(f"  ðŸ“ {item_relative}/ (existente)")
                        else:
                            # Criar nova pasta
                            folder_metadata = {
                                'name': item,
                                'mimeType': 'application/vnd.google-apps.folder',
                                'parents': [parent_id]
                            }
                            
                            subfolder = service.files().create(
                                body=folder_metadata,
                                fields='id'
                            ).execute()
                            
                            subfolder_id = subfolder.get('id')
                            print(f"  ðŸ“ {item_relative}/ (nova)")
                        
                        # Upload recursivo do conteÃºdo
                        sub_count = upload_directory(service, item_path, subfolder_id, 
                                                   os.path.join(path_prefix, item) if path_prefix else item)
                        uploaded_count += sub_count
                        
                    except Exception as e:
                        print(f"  âŒ Erro ao criar pasta {item}: {str(e)[:50]}...")
            
            return uploaded_count
        
        # Criar arquivo de informaÃ§Ãµes da sincronizaÃ§Ã£o
        sync_info = f"""SincronizaÃ§Ã£o automÃ¡tica via GitHub Actions

RepositÃ³rio: {repo_name}
Branch: {branch}
Commit: {commit_sha}
Data/Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
Autor: ${{ github.actor }}
"""
        
        with open('_SYNC_INFO.txt', 'w', encoding='utf-8') as f:
            f.write(sync_info)
        
        # Fazer upload de todos os arquivos
        print("\nðŸ“¤ Fazendo upload dos arquivos...")
        total_uploaded = upload_directory(service, '.', repo_folder_id)
        
        print(f"\nâœ… Total de arquivos enviados: {total_uploaded}")
        print(f"\nðŸŽ‰ SincronizaÃ§Ã£o concluÃ­da com sucesso!")
        print(f"ðŸ“ Pasta no Drive: {repo_name}")
        print(f"ðŸ”— LocalizaÃ§Ã£o: Sistema_GAD/Repositorios_Github_Gad/{repo_name}")
        EOF
        
    - name: Final Summary and Cleanup
      run: |
        python << EOF
        import os
        from datetime import datetime
        
        print("\nðŸ“‹ RESUMO DA SINCRONIZAÃ‡ÃƒO")
        print("=" * 50)
        print(f"âœ… Status: ConcluÃ­da com sucesso")
        print(f"â° HorÃ¡rio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}")
        print(f"ðŸ¢ RepositÃ³rio: ${{ github.event.repository.name }}")
        print(f"ðŸŒ¿ Branch: ${{ github.ref_name }}")
        print(f"ðŸ“ Commit: ${{ github.sha }}")
        print(f"ðŸ‘¤ Autor: ${{ github.actor }}")
        print(f"ðŸŽ¯ Destino: Google Drive/Sistema_GAD/Repositorios_Github_Gad")
        print("=" * 50)
        print("ðŸŽ‰ SincronizaÃ§Ã£o automÃ¡tica concluÃ­da!")
        
        # Limpar arquivos temporÃ¡rios
        print("\nðŸ§¹ Limpando arquivos temporÃ¡rios...")
        temp_files = ['credentials.json', '_SYNC_INFO.txt']
        for file in temp_files:
            if os.path.exists(file):
                os.remove(file)
                print(f"ðŸ—‘ï¸  Removido: {file}")
        EOF
