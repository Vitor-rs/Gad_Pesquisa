name: Sync Repository to Google Drive (OAuth2)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  sync-to-drive:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install Dependencies and Sync to Drive
      run: |
        pip install google-api-python-client google-auth google-auth-oauthlib google-auth-httplib2 requests
        
        python << 'EOF'
        import os
        import sys
        import json
        import requests
        from datetime import datetime
        from pathlib import Path
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaFileUpload
        from google.oauth2.credentials import Credentials
        
        print("ðŸ” Verificando credenciais OAuth2...")
        print("=" * 60)
        
        # ConfiguraÃ§Ãµes do repositÃ³rio
        repo_name = '${{ github.event.repository.name }}'
        branch = '${{ github.ref_name }}'
        commit_sha = '${{ github.sha }}'
        folder_id = '${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}'
        
        # Credenciais OAuth2
        client_id = '${{ secrets.GOOGLE_CLIENT_ID }}'
        client_secret = '${{ secrets.GOOGLE_CLIENT_SECRET }}'
        refresh_token = '${{ secrets.GOOGLE_REFRESH_TOKEN }}'
        
        # Verificar se todas as credenciais estÃ£o presentes
        missing_secrets = []
        if not client_id: missing_secrets.append('GOOGLE_CLIENT_ID')
        if not client_secret: missing_secrets.append('GOOGLE_CLIENT_SECRET')
        if not refresh_token: missing_secrets.append('GOOGLE_REFRESH_TOKEN')
        if not folder_id: missing_secrets.append('GOOGLE_DRIVE_FOLDER_ID')
        
        if missing_secrets:
            print(f"âŒ ERRO: Secrets nÃ£o configurados: {', '.join(missing_secrets)}")
            sys.exit(1)
        
        print("âœ… Todas as credenciais encontradas!")
        print(f"ðŸ“ RepositÃ³rio: {repo_name}")
        print(f"ðŸ”€ Branch: {branch}")
        print(f"ðŸ“ Commit: {commit_sha[:8]}")
        
        # Renovar access token usando refresh token
        print("\nðŸ”„ Renovando access token...")
        
        token_url = "https://oauth2.googleapis.com/token"
        token_data = {
            'client_id': client_id,
            'client_secret': client_secret,
            'refresh_token': refresh_token,
            'grant_type': 'refresh_token'
        }
        
        response = requests.post(token_url, data=token_data)
        
        if response.status_code != 200:
            print(f"âŒ Erro ao renovar token: {response.text}")
            sys.exit(1)
        
        token_info = response.json()
        access_token = token_info['access_token']
        
        print("âœ… Token renovado com sucesso!")
        
        # Criar credenciais para Google Drive API
        credentials = Credentials(
            token=access_token,
            refresh_token=refresh_token,
            token_uri="https://oauth2.googleapis.com/token",
            client_id=client_id,
            client_secret=client_secret,
            scopes=['https://www.googleapis.com/auth/drive']
        )
        
        # Conectar ao Google Drive
        service = build('drive', 'v3', credentials=credentials)
        
        # Testar conexÃ£o
        try:
            about = service.about().get(fields='user').execute()
            user_email = about.get('user', {}).get('emailAddress', 'Desconhecido')
            print(f"âœ… Conectado como: {user_email}")
        except Exception as e:
            print(f"âŒ Erro na conexÃ£o: {e}")
            sys.exit(1)
        
        # Verificar pasta de destino
        try:
            folder_info = service.files().get(fileId=folder_id).execute()
            print(f"ðŸ“ Pasta encontrada: {folder_info.get('name')}")
        except Exception as e:
            print(f"âŒ Pasta nÃ£o encontrada: {e}")
            sys.exit(1)
        
        # FunÃ§Ã£o para upload recursivo
        def upload_directory(local_path, parent_id, path_prefix=""):
            uploaded_count = 0
            
            for item in sorted(os.listdir(local_path)):
                # Ignorar arquivos/pastas indesejados
                if item in ['.git', '__pycache__', 'node_modules', '.github']:
                    continue
                if item.startswith('.') and item != '.gitignore':
                    continue
                    
                item_path = os.path.join(local_path, item)
                item_relative = os.path.join(path_prefix, item) if path_prefix else item
                
                if os.path.isfile(item_path):
                    if item_path.endswith(('.pyc', '.zip')):
                        continue
                        
                    try:
                        file_metadata = {
                            'name': item,
                            'parents': [parent_id]
                        }
                        
                        # Determinar MIME type
                        ext = Path(item_path).suffix.lower()
                        mime_types = {
                            '.txt': 'text/plain',
                            '.py': 'text/x-python',
                            '.md': 'text/markdown',
                            '.json': 'application/json',
                            '.yml': 'text/yaml',
                            '.yaml': 'text/yaml'
                        }
                        mime_type = mime_types.get(ext, 'application/octet-stream')
                        
                        media = MediaFileUpload(item_path, mimetype=mime_type, resumable=True)
                        
                        file = service.files().create(
                            body=file_metadata,
                            media_body=media,
                            fields='id,name'
                        ).execute()
                        
                        print(f"  âœ… {item_relative}")
                        uploaded_count += 1
                        
                    except Exception as e:
                        print(f"  âŒ Erro ao enviar {item_relative}: {str(e)[:50]}...")
                        
                elif os.path.isdir(item_path):
                    try:
                        # Criar pasta
                        folder_metadata = {
                            'name': item,
                            'mimeType': 'application/vnd.google-apps.folder',
                            'parents': [parent_id]
                        }
                        
                        folder = service.files().create(
                            body=folder_metadata,
                            fields='id'
                        ).execute()
                        
                        folder_id = folder.get('id')
                        print(f"  ðŸ“ {item_relative}/")
                        
                        # Upload recursivo do conteÃºdo
                        sub_count = upload_directory(item_path, folder_id, item_relative + "/")
                        uploaded_count += sub_count
                        
                    except Exception as e:
                        print(f"  âŒ Erro ao criar pasta {item}: {str(e)[:50]}...")
            
            return uploaded_count
        
        # Verificar se pasta do repositÃ³rio jÃ¡ existe
        print(f"\nðŸ”„ Sincronizando para Google Drive...")
        
        query = f"name = '{repo_name}' and '{folder_id}' in parents and mimeType = 'application/vnd.google-apps.folder' and trashed = false"
        
        results = service.files().list(
            q=query,
            fields='files(id,name)',
            spaces='drive'
        ).execute()
        
        existing_folders = results.get('files', [])
        
        if existing_folders:
            repo_folder_id = existing_folders[0]['id']
            print(f"ðŸ“ Pasta encontrada: {repo_name}")
            
            # Limpar conteÃºdo existente
            print("ðŸ§¹ Limpando pasta existente...")
            files_query = f"'{repo_folder_id}' in parents and trashed = false"
            files_to_delete = service.files().list(q=files_query, fields='files(id,name)').execute().get('files', [])
            
            for file in files_to_delete:
                try:
                    service.files().delete(fileId=file['id']).execute()
                    print(f"  ðŸ—‘ï¸  Removido: {file['name']}")
                except:
                    pass
        else:
            # Criar nova pasta
            print(f"ðŸ“ Criando pasta: {repo_name}")
            
            folder_metadata = {
                'name': repo_name,
                'mimeType': 'application/vnd.google-apps.folder',
                'parents': [folder_id]
            }
            
            folder = service.files().create(
                body=folder_metadata,
                fields='id'
            ).execute()
            
            repo_folder_id = folder.get('id')
        
        # Criar arquivo de informaÃ§Ãµes da sincronizaÃ§Ã£o
        sync_info = f"""SincronizaÃ§Ã£o automÃ¡tica via GitHub Actions

RepositÃ³rio: {repo_name}
Branch: {branch}
Commit: {commit_sha}
Data/Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
Conta: {user_email}
"""
        
        with open('_SYNC_INFO.txt', 'w', encoding='utf-8') as f:
            f.write(sync_info)
        
        # Fazer upload de todos os arquivos
        print("\nðŸ“¤ Sincronizando arquivos...")
        total_uploaded = upload_directory('.', repo_folder_id)
        
        print(f"\nðŸŽ‰ SincronizaÃ§Ã£o concluÃ­da com sucesso!")
        print("=" * 50)
        print(f"ðŸ“ RepositÃ³rio: {repo_name}")
        print(f"ðŸ”€ Branch: {branch}")
        print(f"ðŸ“ Commit: {commit_sha[:8]}")
        print(f"ðŸ“Š Arquivos processados: {total_uploaded}")
        print(f"ðŸ‘¤ Conta: {user_email}")
        print(f"â° HorÃ¡rio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}")
        print("=" * 50)
        print("âœ¨ SincronizaÃ§Ã£o usando conta institucional concluÃ­da!")
        
        EOF
